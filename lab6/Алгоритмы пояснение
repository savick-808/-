Лабораторная работа 6 (30.10.25)

1. Блочная (корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Принцип работы:
1. Определяется количество корзин (например, по диапазону значений элементов) - ( buckets = [[] for _ in range(n)] )
2. Каждый элемент помещается в корзину согласно функции распределения. - ( idx = int((num - min_val) // interval) )
3. Содержимое каждой корзины сортируется индивидуально (  bkt.sort() )
4. Корзины соединяются в порядке увеличения диапазона ( result.extend(bkt) )

Оценка временной сложности алгоритма: O(n)

Краткое объяснение оценки временной сложности алгоритма: алгоритм работает эффективно, когда элементы равномерно распределены по диапазону значений. Если такое условие выполняется, сортировка осуществляется быстро благодаря небольшим размерам отдельных корзин.


2. Блинная сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

Принцип работы:
1. Найти максимальный элемент в неотсортированной части массива. ( find_max )
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот
элемент оказался первым. ( flip(arr, max_idx) )
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце. ( flip(arr, curr_size - 1) )
4. Повторить процесс для оставшейся неотсортированной части массива. ( while curr_size > 1: )

Оценка временной сложности алгоритма: O(n2)

Краткое объяснение оценки временной сложности алгоритма: каждая операция переворота связана с движением наибольшего элемента в конец массива, и это происходит многократно. Из-за необходимости полного просмотра массива и возможных переворотов, временные затраты увеличиваются квадратично с ростом размера массива.


3. Сортировка бусинами (гравитационная)
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации. Этот алгоритм разработали Джошуа Аруланандхам, Кристиан Калюд и Майкл
Диннин в 2002 году.

Принцип работы:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин,
количество которых соответствует его значению. ( bead_matrix = [[1]*val + [0]*(len(arr)-val) for val in arr]
2. Бусины располагаются на «стержнях» (как на абаке). ( transposed = list(map(list, zip(*bead_matrix))) ) 
3. Под действием «гравитации» бусины падают вниз. ( sorted_transposed = [[1]*sum(row)+[0]*(len(arr)-sum(row)) for row in transposed] )
4. После оседания бусин строки считываются сверху вниз — получается
отсортированный массив. ( final_matrix = list(map(list, zip(*sorted_transposed))) )

Оценка временной сложности алгоритма: O(n)

Краткое объяснение оценки временной сложности алгоритма: алгоритм применим только для неотрицательных целых чисел. Теоретическая сложность —
O(n), но практическая — выше из-за ограничения на диапазон и реализацию.


4. Поиск скачками
Определение: поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.

Принцип работы:
1. Делится массив на блоки длины m=n. ( step = n ) 
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный
искомому. ( while prev < n and arr[min(prev + step, n) - 1] < x: )
3. Если найденный элемент больше искомого, выполняется линейный поиск в
предыдущем блоке. ( for j in range(block_end, prev):  )

Оценка временной сложности алгоритма: O(n)

Краткое объяснение оценки временной сложности алгоритма: оптимален, когда данные отсортированы и доступ к элементам осуществляется за постоянное
время.


5. Экспоненциальный поиск
Определение: экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

Принцип работы:
1. Проверяется первый элемент массива. ( if arr[0] == target: )
2. Если элемент не найден, диапазон увеличивается экспоненциально: 1, 2, 4, 8, 16 и т.д., 
пока не будет найден элемент, больше или равный искомому. ( while i < n and arr[i] <= target: )
3. На найденном диапазоне выполняется бинарный поиск. ( while low <= high: )

Оценка временной сложности алгоритма:  O(log ⁡n)

Краткое объяснение оценки временной сложности алгоритма: общее время работы — O(logN), что эквивалентно бинарному поиску. Тем не менее, преимущество экспоненциального поиска проявляется в случаях, когда массив бесконечен или динамически расширяется, так как фаза экспоненциального роста ограничивает объем рассматриваемых данных.


