Задание 17. Метод ближайшего соседа с улучшением (TSP)
Условие. Построить маршрут TSP методом ближайшего соседа, затем улучшить его 2‑opt.
Алгоритм: комбинация «ближайший сосед» + 2‑opt.
Язык примера: Python
def tsp_hybrid(dist):
 n = len(dist)
 # Шаг 1: ближайший сосед
 path = [0]
 visited = [False] * n
 visited[0] = True
 for _ in range(n - 1):
 curr = path[-1]
 next_city = -1
 # ДОПИСАТЬ: найти ближайший непосещённый город
 path.append(next_city)
 visited[next_city] = True
 # Шаг 2: 2-opt улучшение
 path = twoOpt(path, dist) # использовать функцию из Задания 3
 return path
Что дописать: поиск next_city по минимуму dist[curr][j] среди непосещённых.


1. Описание работы кода и используемого алгоритма
Задача состоит в построении оптимального маршрута путешествия, проходящего через заданное количество вершин (городов) с минимизацией суммарного расстояния.

Данный код реализует комбинацию двух подходов:

Метод ближайшего соседа: Начинаем с произвольного города и каждый раз переходим в ближайший доступный (не посещенный ранее)
Алгоритм 2-opt: Применяется для последующего улучшения полученного маршрута путем последовательного выбора пар ребер и проверки возможности уменьшить длину маршрута заменой этих ребер местами.Таким образом, сначала строится базовый маршрут с использованием эвристики ближайшего соседа, а затем проводится процедура его оптимизации

2. Анализ синтаксиза кода

-twoOpt(route, dist) — функция для оптимизации маршрута методом 2-opt. Она принимает список городов и матрицу расстояний, пытается минимизировать общий пробег маршрутом перебором возможных вариантов замены пары сегментов пути:
   ( best_route = twoOpt(path, dist) ) - в коде

-calculate_total_distance(route, dist) — вспомогательная функция для расчета общей длины текущего маршрута. Используется в процессе сравнения маршрутов при оптимизации:
   ( total_dist = calculate_total_distance(best_route, dist) ) - в коде

-tsp_hybrid(dist) — главная функция, реализующая комбинирование методов «ближайшего соседа» и 2-opt. Сначала строится первоначальный маршрут, затем применяется оптимизация:
   ( path = tsp_hybrid(dist_matrix) ) - в коде

-генерация случайной матрицы расстояний — используется библиотека random для формирования симметричной матрицы расстояний между городами:
   ( dist_matrix = [[random.randint(1, 100) for _ in range(N)] for _ in range(N)] )

-установка нулей на диагонали, указывающей на расстояние от города, до самого себя:
   ( dist_matrix[i][i] = 0 ) 

-выбор следующего города в методе ближайшего соседа осуществляется поиском ближайшей доступной точки среди непройденных узлов: 
   ( min_dist = float('inf') ) 

3. Временная сложность
Временная сложность кода = O(N^3)

4. Описание временной сложности

1) Метод ближайшего соседа: для нахождения ближайшего города в каждом цикле проверяются все оставшиеся узлы. Поскольку количество оставшихся узлов уменьшается линейно с каждым шагом, средняя скрость поиска равна O(N^2)

2) Алгоритм 2-opt: Оптимизация путей требует рассмотрения практически всех возможных соседних позиций. Для каждого возможного сочетания двух рёбер проверяется, можно ли заменить два сегмента на обратные и сократить расстояние. Число возможных перестановок растёт квадратично относительно числа городов, плюс каждая проверка занимает линейное время. Это приводит к асимптотической сложности O(N^3)

В итоговой временной сложности берём самый большой показаьель, а именно алгоритм 2-opt, и получаем временную сложность кода, равную O(N^3)



Ответ на контрольный вопрос 17:

Генетический алгоритм моделирует естественный процесс эволюции и адаптации популяций живых существ. Основными операциями, обеспечивающими работу генетического алгоритма, являются:

1)Отбор выбирает наиболее приспособленные особи (решения) из текущей популяции — чем выше «приспособленность» (значение целевой функции), тем больше шансов у особи участвовать в создании потомства. Это обеспечивает постепенное улучшение качества решений.

2)Кроссовер (скрещивание) комбинирует генетический материал двух выбранных особей-родителей: случайно определяется точка разрыва, и части их хромосом обмениваются, формируя новые хромосомы потомков. Так алгоритм исследует комбинации удачных признаков.

3)Мутация вносит случайные изменения в хромосомы (например, инвертирует отдельные биты) с небольшой вероятностью. Это поддерживает генетическое разнообразие, помогая алгоритму выходить из локальных оптимумов и исследовать новые области пространства решений.







   
