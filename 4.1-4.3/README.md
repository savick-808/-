Вариант 2
 Метод ближайшего соседа (TSP)
Условие: Дан граф городов с расстояниями. Найти приближённый маршрут коммивояжёра, стартуя из города 0.
Алгоритм: ближайший сосед.
Язык примера: Java
public static List<Integer> tspNearest(int[][] dist) {
 List<Integer> path = new ArrayList<>();
 boolean[] visited = new boolean[dist.length];
 int curr = 0;
 path.add(curr);
 visited[curr] = true;
 // ДОПИСАТЬ: цикл выбора ближайшего непосещённого города
 return path;
}
Что дописать: цикл по всем городам с выбором минимума.

Анализ алгоритма:

Алгоритм начинается с произвольного начального города и на каждом шаге движется в ближайший непросмотренный город. Таким образом, на каждом этапе происходит локальный выбор оптимального шага, но глобальная оптимальность не гарантируется. Несмотря на ограниченность точности, этот метод достаточно быстр и полезен для начальных оценочных решений

Общий ход работы алгоритма:
1.Инициализация:
Начнём с первого города (условно обозначаемого номером 0). Запишем его в качестве первой точки маршрута и пометим как посещённую. ( path.add(curr); visited[curr] = true )

2.Основной цикл:
Пока остаются необследованные города, выполняем следующее:
1)Рассчитываем расстояние от текущего города ко всем другим непросмотренным городам (tspNearest(int[][] dist))
2)Выбираем ближайший город, переходя в него и добавив его в маршрут (for (int j = 0; j < dist.length; j++)); (path.add(nearest))
3)Отмечаем новый город как посещённый и повторяем процесс (visited[nearest] = true)

3.Формирование конечного маршрута: После просмотра всех городов формируем полный маршрут, начиная с первого города и заканчивая им же ( path )

4.Вычисление длины маршрута:Просчитывается сумма расстояний между последовательными городами, образующими полученный маршрут  (for (int i = 0; i < route.size() - 1; i++)) 

Скорость:Алгоритм работает быстро даже на крупных наборах данных, поскольку на каждом шаге необходим лишь выбор ближайшего соседа, что занимает O(n) времени.
